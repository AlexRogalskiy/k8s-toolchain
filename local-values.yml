jenkins:
  Agent:
    Privileged: true
    volumes:
    - type: HostPath
      hostPath: /var/run/docker.sock
      mountPath: /var/run/docker.sock
  Master:
    NodePort: 30080
    ServiceType: NodePort
    InstallPlugins:
    - kubernetes:1.3.1
    - workflow-aggregator:2.5
    - workflow-job:2.17
    - credentials-binding:1.15
    - git:3.8.0
    InitScripts:
    - |
      // Docker access and agent idle time - 5 mins
      import jenkins.model.Jenkins
      import org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate
      if(!Jenkins.instance.isQuietingDown()) {
          def j = Jenkins.instance
          j.clouds[0].templates[0].idleMinutes = 5
          dockerContainer = new ContainerTemplate('docker', 'docker') 
          dockerContainer.with {
            command='/bin/sh -c'
            args='cat'
            privileged=true
            ttyEnabled=true
          }
          j.clouds[0].templates[0].containers[1] = dockerContainer

          helmContainer = new ContainerTemplate('helm', 'cplee/k8s-helm:v2.8.1') 
          helmContainer.with {
            command='/bin/sh -c'
            args='cat'
            ttyEnabled=true
          }
          j.clouds[0].templates[0].containers[2] = helmContainer

          regContainer = new ContainerTemplate('reg', 'cplee/reg') 
          regContainer.with {
            command='/bin/sh -c'
            args='cat'
            ttyEnabled=true
          }
          j.clouds[0].templates[0].containers[3] = regContainer

          skopeoContainer = new ContainerTemplate('skopeo', 'runcom/skopeo') 
          skopeoContainer.with {
            command='/bin/sh -c'
            args='cat'
            ttyEnabled=true
          }
          j.clouds[0].templates[0].containers[4] = skopeoContainer
      } else {
          println "Shutdown mode enabled.  Configure CSRF protection SKIPPED."
      }
    - |
      // CSRF
      import hudson.security.csrf.DefaultCrumbIssuer
      import jenkins.model.Jenkins

      if(!Jenkins.instance.isQuietingDown()) {
          def j = Jenkins.instance
          if(j.getCrumbIssuer() == null) {
              j.setCrumbIssuer(new DefaultCrumbIssuer(true))
              j.save()
              println 'CSRF Protection configuration has changed.  Enabled CSRF Protection.'
          }
          else {
              println 'Nothing changed.  CSRF Protection already configured.'
          }
      }
      else {
          println "Shutdown mode enabled.  Configure CSRF protection SKIPPED."
      }
    - |
      // DISABLE CLI
      import jenkins.model.Jenkins

      if(!Jenkins.instance.isQuietingDown()) {
        jenkins.model.Jenkins.instance.getDescriptor("jenkins.CLI").get().setEnabled(false)
      } else {
          println 'Shutdown mode enabled.  Disable CLI SKIPPED.'
      }

    - |
      // DISABLE OLD AGENT PROTOCOLS
      import jenkins.model.Jenkins
      Jenkins j = Jenkins.instance

      if(!j.isQuietingDown()) {
          Set<String> agentProtocolsList = ['JNLP4-connect', 'Ping']
          if(!j.getAgentProtocols().equals(agentProtocolsList)) {
              j.setAgentProtocols(agentProtocolsList)
              println "Agent Protocols have changed.  Setting: ${agentProtocolsList}"
              j.save()
          }
          else {
              println "Nothing changed.  Agent Protocols already configured: ${j.getAgentProtocols()}"
          }
      }
      else {
          println 'Shutdown mode enabled.  Configure Agent Protocols SKIPPED.'
      }

docker-registry:
 tlsSecretName: toolchain-docker-registry 

clair:
  replicaCount: 1
  logLevel: info
  insecureTls: false
  image:
    repository: quay.io/coreos/clair
    tag: v2.0.1
    pullPolicy: Always
  service:
    name: clair
    type: ClusterIP
    internalApiPort: 6060
    externalApiPort: 6060
    internalHealthPort: 6061
    externalHealthPort: 6061
  ingress:
    enabled: false
    # Used to create Ingress record (should used with service.type: ClusterIP).
    hosts:
      - chart-example.local
    annotations:
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    tls:
      # Secrets must be manually created in the namespace.
      # - secretName: chart-example-tls
      #   hosts:
      #     - chart-example.local
  resources:
    limits:
      cpu: 100m
      memory: 1Gi
    requests:
      cpu: 100m
      memory: 500Mi
  config:
    # postgresURI: "postgres://user:password@host:5432/postgres?sslmode=disable"
    paginationKey: "XxoPtCUzrUv4JV5dS+yQ+MdW7yLEJnRMwigVY/bpgtQ="
    updateInterval: 2h
    notificationWebhookEndpoint: https://example.com/notify/me
    enabledUpdaters:
    - debian
    - ubuntu
    - rhel
    - oracle
    - alpine
    enabledNamespaceDetectors:
    - os-release
    - lsb-release
    - apt-sources
    - alpine-release
    - redhat-release
    enabledFeatureListers:
    - apk
    - dpkg
    - rpm

  postgresql:
    postgresUser: clair
    postgresPassword: clair
    postgresDatabase: clair

postgresql:
  enabled: true
  cpu: 1000m
  memory: 1Gi
# These values are hardcoded until Helm supports secrets.
# For more info see: https://github.com/kubernetes/helm/issues/2196
  postgresUser: clair
  postgresPassword: clair
  postgresDatabase: clair

  persistence:
    size: 10Gi
